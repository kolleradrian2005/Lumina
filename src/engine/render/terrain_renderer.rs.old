use std::ffi::CString;

use crate::frame_buffer::Framebuffer;
use crate::shader::Shader;
use crate::shader_program::ShaderProgram;
use crate::texture_handler::TextureHandler;
use crate::vec2::Vec2;
use crate::{model::Model, scene::Scene};
use crate::{terrain, window_handler};

pub struct TerrainRenderer {
    shader: ShaderProgram,
}

impl TerrainRenderer {
    pub fn init() -> Self {
        let fragment_shader = Shader::new("terrain.frag", gl::FRAGMENT_SHADER);
        let vertex_shader = Shader::new("terrain.vert", gl::VERTEX_SHADER);
        let shader_program = ShaderProgram::new(&[vertex_shader, fragment_shader]);
        shader_program.bind_attributes(0, "position");
        shader_program.bind_attributes(1, "uv");
        TerrainRenderer {
            shader: shader_program,
        }
    }

    pub fn render(&self, scene: &mut Scene, framebuffer: &mut Framebuffer) {
        self.shader.start();
        // TODO: Use terrain.model OR fullscreen model
        let start_x = -1;
        let end_x = 1;
        let resolution = scene.terrain.resolution;
        unsafe {
            // Renders terrain parts each 1 x changes (Could be optimized)
            for x in (resolution*start_x)..(end_x*resolution) {
                //let x: f32 = raw_x as f32/ resolution as f32;
                //let focal_offset = &scene.focal_offset;

                let model_location = gl::GetUniformLocation(self.shader.id, std::ffi::CStr::as_ptr(&CString::new("uModelMatrix").unwrap()));
                let view_location = gl::GetUniformLocation(self.shader.id, std::ffi::CStr::as_ptr(&CString::new("uViewMatrix").unwrap()));
                let projection_location = gl::GetUniformLocation(self.shader.id, std::ffi::CStr::as_ptr(&CString::new("uProjectionMatrix").unwrap()));
                
                let height = scene.terrain.get_height(x);
                let model_position = Vec2::new(x as f32 / resolution as f32, height);
                let model = &mut scene.terrain.tile_model;
                model.set_position(model_position);
                let view_matrix = scene.camera.get_view_matrix();
                let projection_matrix = scene.camera.get_projection_matrix();
                let model_matrix = model.get_model_matrix();

                gl::UniformMatrix4fv(model_location, 1, gl::FALSE, model_matrix.as_ptr() as * const f32);
                gl::UniformMatrix4fv(view_location, 1, gl::FALSE, view_matrix.as_ptr() as * const f32);
                gl::UniformMatrix4fv(projection_location, 1, gl::FALSE, projection_matrix.as_ptr() as * const f32);

                gl::BindVertexArray(model.get_vao());
                gl::EnableVertexAttribArray(0);
                gl::EnableVertexAttribArray(1);
                gl::DrawElements(
                    gl::TRIANGLES,
                    model.get_vertex_count(),
                    gl::UNSIGNED_INT,
                    0 as *const _,
                );
                gl::DisableVertexAttribArray(0);
                gl::DisableVertexAttribArray(1);
                gl::BindVertexArray(0);
            }
        };
        self.shader.stop();
    }
}
