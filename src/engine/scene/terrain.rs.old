use std::collections::VecDeque;

use noise::{NoiseFn, Perlin};

use crate::{model::Model, vec2::Vec2};

extern crate noise;

pub struct Terrain {
    width: usize, // Must be odd
    noise: Perlin,
    pub tile_size: f32,
    loaded_tiles: VecDeque<Model>,
    loaded_tile_index: i32,
    default_tile_count: i32
}

impl Terrain {
    pub fn new(raw_width: usize, seed: u32) -> Self {
        let noise = Perlin::new(seed);
        let tile_size = 0.1;
        let loaded_tiles = VecDeque::new();
        let loaded_tile_index: i32 = 0;
        let mut width = raw_width;
        width += 1 - (width % 2);
        let mut default_tile_count = (2.0 / tile_size as f32) as i32 + 2;
        default_tile_count -= default_tile_count % 2;
        Terrain { width, noise, tile_size, loaded_tiles, loaded_tile_index, default_tile_count }
    }
    pub fn load_default_tiles(&mut self) {
        self.loaded_tiles.push_back(self.generate_tile(self.loaded_tile_index as f32));
        for i in 1..self.default_tile_count / 2 + 1 as i32 {
            self.loaded_tiles.push_back(self.generate_tile((self.loaded_tile_index + i) as f32 * self.tile_size));
            self.loaded_tiles.push_front(self.generate_tile((self.loaded_tile_index - i) as f32 * self.tile_size));
        }
        
    }
    fn generate_tile(&self, x: f32) -> Model {
        let previous_y: f32 = self.get_height((x - 1.0) as i32);
        let current_y: f32 = self.get_height(x as i32);
        let next_y: f32 = self.get_height((x + 1.0) as i32);
        let left_y_offset = (previous_y - current_y) / 2.0;
        let right_y_offset = (next_y - current_y) / 2.0;
        let vertices: &[f32] = &[
            // Bottom left
            -self.tile_size / 2.0, -self.tile_size / 2.0, 1.0,
            // Bottom right
            self.tile_size / 2.0, -self.tile_size / 2.0, 1.0,
            // Top right
            self.tile_size / 2.0, self.tile_size / 2.0, 1.0,
            //self.tile_size / 2.0, self.tile_size / 2.0 + right_y_offset, 1.0,
            // Top left
            -self.tile_size / 2.0, self.tile_size / 2.0, 1.0
            //-self.tile_size / 2.0, self.tile_size / 2.0 + left_y_offset, 1.0,
        ];
        println!("{:?} {:?} {:?} {:?}", vertices[6], vertices[7], vertices[9], vertices[10]);
        let indices: &[u32] = &[
            0, 1, 2,
            2, 3, 0
        ];

        let uvs: &[f32] = &[
            0.0, 0.0,
            1.0, 0.0,
            1.0, 1.0,
            0.0, 1.0,
        ];
        let mut tile: Model = Model::new(vertices, indices, uvs);
        tile.set_position(Vec2::new(x, current_y));
        tile
    }
    pub fn get_width(&self) -> usize {
        self.width
    }
    pub fn get_height(&self, x: i32) -> f32 {
        let mut x = (x as f32 * 7.5) as i32;
        let mapped_x = x + ((self.width as i32) + 1) / 2;
        let frequency = 1.0;
        let amplitude = 7.5;
        //if (self.width as i32) < mapped_x {
        //    return 0.0;
        //}
        let normalized_x = mapped_x as f64 / self.width as f64;
        let noise_value = self.noise.get([normalized_x * frequency, 0.0]);
        let scaled_height = (noise_value * 1.0) as f32;
        scaled_height as f32
    }
    pub fn get_loaded_tiles(&self) -> &VecDeque<Model> {
        &self.loaded_tiles
    }

    pub fn update_tile_index(&mut self, tile_index: i32) {
        let difference = self.loaded_tile_index - tile_index; 
        if difference != 0 {
            self.loaded_tile_index = tile_index;
            if difference > 0 {
                self.sweep_left();
            } else {
                self.sweep_right();
            }
        }
    }

    fn sweep_left(&mut self) {
        let new_tile = self.generate_tile((self.loaded_tile_index - self.default_tile_count / 2) as f32 * self.tile_size);
        self.loaded_tiles.push_front(new_tile);
        self.loaded_tiles.pop_back();
    }
    fn sweep_right(&mut self) {
        let new_tile = self.generate_tile((self.loaded_tile_index + self.default_tile_count / 2) as f32 * self.tile_size);
        self.loaded_tiles.push_back(new_tile);
        self.loaded_tiles.pop_front();
    }
}
